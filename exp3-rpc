XML RPC:

Xml_server.py

from xmlrpc.server import SimpleXMLRPCServer


def get_fib_number(n):
   a, b = 0, 1
   for _ in range(n - 1):
       a, b = b, a + b
   return b


server = SimpleXMLRPCServer(("localhost", 8000), logRequests=False)
print("XML-RPC server listening on port 8000...")
server.register_function(get_fib_number, "get_fib")
server.serve_forever()





Xml_client.py

import xmlrpc.client
import time
import statistics


proxy = xmlrpc.client.ServerProxy("http://localhost:8000/", allow_none=True)


FIB_POSITION = 25
TEST_RUNS = [100, 1000, 10000]


# Measure payload size
request_payload = xmlrpc.client.dumps(((FIB_POSITION,),))
response_payload = xmlrpc.client.dumps((proxy.get_fib(FIB_POSITION),))
PAYLOAD_SIZE_BYTES = len(request_payload) + len(response_payload)


print("--- Starting XML-RPC Performance Test ---")


for num_requests in TEST_RUNS:
   latencies = []
   print(f"\n--- Running for {num_requests} requests ---")


   cpu_start = time.process_time()
   total_start_time = time.perf_counter()


   for _ in range(num_requests):
       req_start_time = time.perf_counter()
       result = proxy.get_fib(FIB_POSITION)
       req_end_time = time.perf_counter()
       latencies.append((req_end_time - req_start_time) * 1000)


   total_end_time = time.perf_counter()
   cpu_end = time.process_time()
  
   total_time = total_end_time - total_start_time
   total_cpu_time = cpu_end - cpu_start


   print(f"Fibonacci Number at position (n count): {FIB_POSITION+1}")
   print(f"Final Fibonacci Result: {result}")
   print(f"Execution Time: {total_time:.4f} seconds")
   print(f"CPU Utilization Time: {total_cpu_time:.4f} seconds")
   print(f"Bandwidth per Request (Payload Size): {PAYLOAD_SIZE_BYTES} bytes")
   print(f"Requests Per Second (Throughput): {num_requests / total_time:.2f} RPS")
   print(f"Latency (ms) - Average: {statistics.mean(latencies):.4f}, StdDev: {statistics.stdev(latencies):.4f}")

PYRO5 RPC:

Pyro5 server:

import Pyro5.api


@Pyro5.api.expose
class FibonacciCalculator:
   def fib(self, n):
       if n <= 0:
           return []
       elif n == 1:
           return [0]
       fib_seq = [0, 1]
       for i in range(2, n):
           fib_seq.append(fib_seq[-1] + fib_seq[-2])
       return fib_seq


def main():
   daemon = Pyro5.api.Daemon()  # start Pyro daemon
   uri = daemon.register(FibonacciCalculator)
   print("Ready. Object uri =", uri)
   daemon.requestLoop()


if __name__ == "__main__":
   main()



pyro client:

import Pyro5.api
import time
import psutil
import sys
import random


# Replace this with the actual URI printed by your server
uri = "PYRO:obj_553a3e67656747329f11d5052d62fcf5@localhost:43837"  # placeholder


def get_size(obj, seen=None):
   """Recursively finds size of objects for bandwidth approx."""
   size = sys.getsizeof(obj)
   if seen is None:
       seen = set()
   obj_id = id(obj)
   if obj_id in seen:
       return 0
   seen.add(obj_id)
   if isinstance(obj, dict):
       size += sum([get_size(v, seen) + get_size(k, seen) for k, v in obj.items()])
   elif hasattr(obj, '__dict__'):
       size += get_size(obj.__dict__, seen)
   elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):
       size += sum([get_size(i, seen) for i in obj])
   return size


def benchmark_requests(calculator, num_requests):
   process = psutil.Process()
   total_time = 0.0
   total_bandwidth = 0
   cpu_times_start = process.cpu_times()
  
   latencies = []
   for _ in range(num_requests):
       n = random.randint(10, 100)  # Random n between 10 and 100 for each request
       start_time = time.perf_counter()
       result = calculator.fib(n)
       end_time = time.perf_counter()


       latency = end_time - start_time
       latencies.append(latency)
      
       total_time += latency
       total_bandwidth += get_size(result)
  
   cpu_times_end = process.cpu_times()XML RPC:

Xml_server.py

from xmlrpc.server import SimpleXMLRPCServer


def get_fib_number(n):
   a, b = 0, 1
   for _ in range(n - 1):
       a, b = b, a + b
   return b


server = SimpleXMLRPCServer(("localhost", 8000), logRequests=False)
print("XML-RPC server listening on port 8000...")
server.register_function(get_fib_number, "get_fib")
server.serve_forever()





Xml_client.py

import xmlrpc.client
import time
import statistics


proxy = xmlrpc.client.ServerProxy("http://localhost:8000/", allow_none=True)


FIB_POSITION = 25
TEST_RUNS = [100, 1000, 10000]


# Measure payload size
request_payload = xmlrpc.client.dumps(((FIB_POSITION,),))
response_payload = xmlrpc.client.dumps((proxy.get_fib(FIB_POSITION),))
PAYLOAD_SIZE_BYTES = len(request_payload) + len(response_payload)


print("--- Starting XML-RPC Performance Test ---")


for num_requests in TEST_RUNS:
   latencies = []
   print(f"\n--- Running for {num_requests} requests ---")


   cpu_start = time.process_time()
   total_start_time = time.perf_counter()


   for _ in range(num_requests):
       req_start_time = time.perf_counter()
       result = proxy.get_fib(FIB_POSITION)
       req_end_time = time.perf_counter()
       latencies.append((req_end_time - req_start_time) * 1000)


   total_end_time = time.perf_counter()
   cpu_end = time.process_time()
  
   total_time = total_end_time - total_start_time
   total_cpu_time = cpu_end - cpu_start


   print(f"Fibonacci Number at position (n count): {FIB_POSITION+1}")
   print(f"Final Fibonacci Result: {result}")
   print(f"Execution Time: {total_time:.4f} seconds")
   print(f"CPU Utilization Time: {total_cpu_time:.4f} seconds")
   print(f"Bandwidth per Request (Payload Size): {PAYLOAD_SIZE_BYTES} bytes")
   print(f"Requests Per Second (Throughput): {num_requests / total_time:.2f} RPS")
   print(f"Latency (ms) - Average: {statistics.mean(latencies):.4f}, StdDev: {statistics.stdev(latencies):.4f}")

PYRO5 RPC:

Pyro5 server:

import Pyro5.api


@Pyro5.api.expose
class FibonacciCalculator:
   def fib(self, n):
       if n <= 0:
           return []
       elif n == 1:
           return [0]
       fib_seq = [0, 1]
       for i in range(2, n):
           fib_seq.append(fib_seq[-1] + fib_seq[-2])
       return fib_seq


def main():
   daemon = Pyro5.api.Daemon()  # start Pyro daemon
   uri = daemon.register(FibonacciCalculator)
   print("Ready. Object uri =", uri)
   daemon.requestLoop()


if __name__ == "__main__":
   main()



pyro client:

import Pyro5.api
import time
import psutil
import sys
import random


# Replace this with the actual URI printed by your server
uri = "PYRO:obj_553a3e67656747329f11d5052d62fcf5@localhost:43837"  # placeholder


def get_size(obj, seen=None):
   """Recursively finds size of objects for bandwidth approx."""
   size = sys.getsizeof(obj)
   if seen is None:
       seen = set()
   obj_id = id(obj)
   if obj_id in seen:
       return 0
   seen.add(obj_id)
   if isinstance(obj, dict):
       size += sum([get_size(v, seen) + get_size(k, seen) for k, v in obj.items()])
   elif hasattr(obj, '__dict__'):
       size += get_size(obj.__dict__, seen)
   elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):
       size += sum([get_size(i, seen) for i in obj])
   return size


def benchmark_requests(calculator, num_requests):
   process = psutil.Process()
   total_time = 0.0
   total_bandwidth = 0
   cpu_times_start = process.cpu_times()
  
   latencies = []
   for _ in range(num_requests):
       n = random.randint(10, 100)  # Random n between 10 and 100 for each request
       start_time = time.perf_counter()
       result = calculator.fib(n)
       end_time = time.perf_counter()


       latency = end_time - start_time
       latencies.append(latency)
      
       total_time += latency
       total_bandwidth += get_size(result)
  
   cpu_times_end = process.cpu_times()
   cpu_time_used = (cpu_times_end.user - cpu_times_start.user) + (cpu_times_end.system - cpu_times_start.system)


   avg_latency = total_time / num_requests
   avg_bandwidth = total_bandwidth / num_requests


   print(f"Requests: {num_requests}")
   print(f"Average latency per request: {avg_latency * 1000:.3f} ms")
   print(f"Total execution time: {total_time:.3f} s")
   print(f"CPU time used: {cpu_time_used:.3f} s")
   print(f"Approximate average bandwidth consumption per response: {avg_bandwidth / 1024:.3f} KB")


def main():
   calculator = Pyro5.api.Proxy(uri)


   while True:
       print("\nChoose an option:")
       print("1. Send custom Fibonacci request")
       print("2. Benchmark with random n (10-100) for 100, 1000, 10000 requests")
       print("3. Exit")
       choice = input("Enter choice (1/2/3): ").strip()


       if choice == "1":
           n = input("Enter Fibonacci sequence length (positive integer): ").strip()
           if not n.isdigit() or int(n) <= 0:
               print("Please enter a valid positive integer.")
               continue
           n = int(n)
           start_time = time.perf_counter()
           result = calculator.fib(n)
           end_time = time.perf_counter()
           print(f"Fibonacci sequence up to {n}: {result}")
           print(f"Execution time: {(end_time - start_time)*1000:.3f} ms")


       elif choice == "2":
           print("Running benchmark for 100 requests...")
           benchmark_requests(calculator, 100)
           print("\nRunning benchmark for 1000 requests...")
           benchmark_requests(calculator, 1000)
           print("\nRunning benchmark for 10000 requests...")
           benchmark_requests(calculator, 10000)


       elif choice == "3":
           print("Exiting...")
           break
       else:
           print("Invalid choice. Please select 1, 2, or 3.")


if __name__ == "__main__":
   main()

gRPC:


grpc_proto

syntax = "proto3";


service Fibonacci {
  rpc GetSequence (FibonacciRequest) returns (FibonacciResponse);
}


message FibonacciRequest {
  int32 n = 1;  // Generate Fibonacci numbers up to this value (inclusive)
}


message FibonacciResponse {
  repeated int64 sequence = 1;  // List of Fibonacci numbers up to n
}



grpc_server

import grpc
from concurrent import futures
import fibonacci_pb2
import fibonacci_pb2_grpc


class FibonacciServicer(fibonacci_pb2_grpc.FibonacciServicer):
   def GetSequence(self, request, context):
       n = request.n
       sequence = []
       a, b = 0, 1
       for _ in range(n):  # generate first n Fibonacci numbers
           sequence.append(a)
           a, b = b, a + b


       return fibonacci_pb2.FibonacciResponse(sequence=sequence)




def serve():
   server = grpc.server(futures.ThreadPoolExecutor(max_workers=4))
   fibonacci_pb2_grpc.add_FibonacciServicer_to_server(FibonacciServicer(), server)
   server.add_insecure_port('[::]:50051')
   print("gRPC Server running on port 50051...")
   server.start()
   server.wait_for_termination()


if __name__ == '__main__':
   serve()





grpc_client

import grpc
import fibonacci_pb2
import fibonacci_pb2_grpc
import time
import psutil
import sys


def measure_bandwidth(request, response):
   """Estimate bandwidth per request by serialized message size (in bytes)."""
   request_size = sys.getsizeof(request.SerializeToString())
   response_size = sys.getsizeof(response.SerializeToString())
   return request_size + response_size  # total bytes transferred


def run(n, num_requests):
   channel = grpc.insecure_channel('localhost:50051')
   stub = fibonacci_pb2_grpc.FibonacciStub(channel)


   # Get CPU time before starting requests
   cpu_times_before = psutil.cpu_times()


   start_time = time.time()
   total_bandwidth = 0
   latencies = []


   for _ in range(num_requests):
       req_start = time.time()
       response = stub.GetSequence(fibonacci_pb2.FibonacciRequest(n=n))
       req_end = time.time()


       latencies.append(req_end - req_start)


       # Measure bandwidth per request
       total_bandwidth += measure_bandwidth(
           fibonacci_pb2.FibonacciRequest(n=n), response
       )


   end_time = time.time()
   cpu_times_after = psutil.cpu_times()


   # Calculate actual CPU time used during the request period (user + system)
   cpu_time_used = (
       (cpu_times_after.user - cpu_times_before.user) +
       (cpu_times_after.system - cpu_times_before.system)
   )


   # Compute metrics
   total_time = end_time - start_time
   avg_latency = sum(latencies) / len(latencies)
   avg_bandwidth = total_bandwidth / num_requests  # bytes/request


   # Output results
   print(f"\nFor n = {n} and {num_requests} requests:")
   print(f"Execution Time: {total_time:.4f} seconds")
   print(f"Average Latency per request: {avg_latency * 1000:.4f} ms")
   print(f"CPU Utilization Time: {cpu_time_used:.4f} seconds")
   print(f"Average Bandwidth per request: {avg_bandwidth:.1f} bytes")


   # Print nth Fibonacci number (assuming sequence includes n items)
   if response.sequence:
       print(f"Fibonacci number at position n: {response.sequence[-1]}")
   else:
       print("Received empty Fibonacci sequence")


if __name__ == '__main__':
   test_ns = [26]  # Fibonacci up to the 26th position
   test_requests = [100, 1000, 10000]


   for n in test_ns:
       for req_count in test_requests:
           run(n, req_count)
   cpu_time_used = (cpu_times_end.user - cpu_times_start.user) + (cpu_times_end.system - cpu_times_start.system)


   avg_latency = total_time / num_requests
   avg_bandwidth = total_bandwidth / num_requests


   print(f"Requests: {num_requests}")
   print(f"Average latency per request: {avg_latency * 1000:.3f} ms")
   print(f"Total execution time: {total_time:.3f} s")
   print(f"CPU time used: {cpu_time_used:.3f} s")
   print(f"Approximate average bandwidth consumption per response: {avg_bandwidth / 1024:.3f} KB")


def main():
   calculator = Pyro5.api.Proxy(uri)


   while True:
       print("\nChoose an option:")
       print("1. Send custom Fibonacci request")
       print("2. Benchmark with random n (10-100) for 100, 1000, 10000 requests")
       print("3. Exit")
       choice = input("Enter choice (1/2/3): ").strip()


       if choice == "1":
           n = input("Enter Fibonacci sequence length (positive integer): ").strip()
           if not n.isdigit() or int(n) <= 0:
               print("Please enter a valid positive integer.")
               continue
           n = int(n)
           start_time = time.perf_counter()
           result = calculator.fib(n)
           end_time = time.perf_counter()
           print(f"Fibonacci sequence up to {n}: {result}")
           print(f"Execution time: {(end_time - start_time)*1000:.3f} ms")


       elif choice == "2":
           print("Running benchmark for 100 requests...")
           benchmark_requests(calculator, 100)
           print("\nRunning benchmark for 1000 requests...")
           benchmark_requests(calculator, 1000)
           print("\nRunning benchmark for 10000 requests...")
           benchmark_requests(calculator, 10000)


       elif choice == "3":
           print("Exiting...")
           break
       else:
           print("Invalid choice. Please select 1, 2, or 3.")


if __name__ == "__main__":
   main()

gRPC:


grpc_proto

syntax = "proto3";


service Fibonacci {
  rpc GetSequence (FibonacciRequest) returns (FibonacciResponse);
}


message FibonacciRequest {
  int32 n = 1;  // Generate Fibonacci numbers up to this value (inclusive)
}


message FibonacciResponse {
  repeated int64 sequence = 1;  // List of Fibonacci numbers up to n
}



grpc_server

import grpc
from concurrent import futures
import fibonacci_pb2
import fibonacci_pb2_grpc


class FibonacciServicer(fibonacci_pb2_grpc.FibonacciServicer):
   def GetSequence(self, request, context):
       n = request.n
       sequence = []
       a, b = 0, 1
       for _ in range(n):  # generate first n Fibonacci numbers
           sequence.append(a)
           a, b = b, a + b


       return fibonacci_pb2.FibonacciResponse(sequence=sequence)




def serve():
   server = grpc.server(futures.ThreadPoolExecutor(max_workers=4))
   fibonacci_pb2_grpc.add_FibonacciServicer_to_server(FibonacciServicer(), server)
   server.add_insecure_port('[::]:50051')
   print("gRPC Server running on port 50051...")
   server.start()
   server.wait_for_termination()


if __name__ == '__main__':
   serve()





grpc_client

import grpc
import fibonacci_pb2
import fibonacci_pb2_grpc
import time
import psutil
import sys


def measure_bandwidth(request, response):
   """Estimate bandwidth per request by serialized message size (in bytes)."""
   request_size = sys.getsizeof(request.SerializeToString())
   response_size = sys.getsizeof(response.SerializeToString())
   return request_size + response_size  # total bytes transferred


def run(n, num_requests):
   channel = grpc.insecure_channel('localhost:50051')
   stub = fibonacci_pb2_grpc.FibonacciStub(channel)


   # Get CPU time before starting requests
   cpu_times_before = psutil.cpu_times()


   start_time = time.time()
   total_bandwidth = 0
   latencies = []


   for _ in range(num_requests):
       req_start = time.time()
       response = stub.GetSequence(fibonacci_pb2.FibonacciRequest(n=n))
       req_end = time.time()


       latencies.append(req_end - req_start)


       # Measure bandwidth per request
       total_bandwidth += measure_bandwidth(
           fibonacci_pb2.FibonacciRequest(n=n), response
       )


   end_time = time.time()
   cpu_times_after = psutil.cpu_times()


   # Calculate actual CPU time used during the request period (user + system)
   cpu_time_used = (
       (cpu_times_after.user - cpu_times_before.user) +
       (cpu_times_after.system - cpu_times_before.system)
   )


   # Compute metrics
   total_time = end_time - start_time
   avg_latency = sum(latencies) / len(latencies)
   avg_bandwidth = total_bandwidth / num_requests  # bytes/request


   # Output results
   print(f"\nFor n = {n} and {num_requests} requests:")
   print(f"Execution Time: {total_time:.4f} seconds")
   print(f"Average Latency per request: {avg_latency * 1000:.4f} ms")
   print(f"CPU Utilization Time: {cpu_time_used:.4f} seconds")
   print(f"Average Bandwidth per request: {avg_bandwidth:.1f} bytes")


   # Print nth Fibonacci number (assuming sequence includes n items)
   if response.sequence:
       print(f"Fibonacci number at position n: {response.sequence[-1]}")
   else:
       print("Received empty Fibonacci sequence")


if __name__ == '__main__':
   test_ns = [26]  # Fibonacci up to the 26th position
   test_requests = [100, 1000, 10000]


   for n in test_ns:
       for req_count in test_requests:
           run(n, req_count)
